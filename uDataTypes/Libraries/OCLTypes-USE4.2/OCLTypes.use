--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- Extended OCL Types
--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
model OCLTypes

-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- UString

class UString

attributes 
s : String
c : Real

operations

--- *************************
--- String operations

size() : Integer = self.s.size()

substring(lower:Integer, upper:Integer): String = self.s.substring(lower,upper)
pre validLimits: (1 <= lower) and (lower <= upper) and (upper <= self.size())

toString() : String = self.s

equals(us:UString):Boolean = (self.s=us.s) and (self.c=us.c)

indexOf(s:String):Integer = self.s.indexOf(s)
post selfEmptyOK: self.size() = 0 implies result = 0
post sEmptyOK: s.size() = 0 implies result = 1
post OK: s.size() > 0 and result > 0 implies self.substring(result, result + s.size() - 1) = s

at(i:Integer):String = self.s.substring(i, i)
pre: i > 0
pre: i <= self.size()

characters() : Sequence(String) = self.s.characters()

toBoolean():Boolean = self.s.toBoolean()

toReal():Real = self.s.toReal()

toUpperCase():String = self.s.toUpperCase()

toLowerCase():String = self.s.toLowerCase()

--- *************************
--- Auxiliary operations

-- returns the corresponding Levenshtein Distance
confToDist() : Real = self.s.size()*(1.0 - self.c)

distToConf(dist:Real, l:Integer):Real = (1.0-dist/l).max(0.0)

levenshteinDist(s1:String, s2:String):Integer

-- int levenshtein(char *s1, char *s2) {
--    unsigned int s1len, s2len, x, y, lastdiag, olddiag;
--    s1len = strlen(s1);
--    s2len = strlen(s2);
--    unsigned int column[s1len+1];
--    for (y = 1; y <= s1len; y++)
--        column[y] = y;
--    for (x = 1; x <= s2len; x++) {
--        column[0] = x;
--        for (y = 1, lastdiag = x-1; y <= s1len; y++) {
--            olddiag = column[y];
--            column[y] = MIN3(column[y] + 1, column[y-1] + 1, lastdiag + (s1[y-1] == s2[x-1] ? 0 : 1));
--            lastdiag = olddiag;
--        }
--    }
--    return(column[s1len]);
-- }

begin
    declare column:Sequence(Integer), z:Integer, lastdiag:Integer, olddiag:Integer,s1len:Integer, s2len:Integer;
--	s1 := s1.toLowerCase();
--  s2 := s2.toLowerCase();
	s1len:=s1.size();
	s2len:=s2.size();
	column:=Sequence{0..s1len};
	for x in Sequence{1..s2len} do
		column:=Sequence{x}->union(column->subSequence(2,column->size()));
		lastdiag:=x-1;
		for y in Sequence{1..s1len} do
			olddiag:=column->at(y+1);
			z:=((column->at(y+1)).min(column->at(y+1).min(lastdiag + if (s1.at(y)=s2.at(x)) then 0  else 1 endif)));
			-- column->at(y+1):=z;
			if (y+2>column->size()) then 
				column:=(column->subSequence(1,y))->union(Sequence{z});
			else 
				column:=(column->subSequence(1,y))->union(Sequence{z}->union(column->subSequence(y+2,column->size())));
			end;
			lastdiag:=olddiag;
		end;
	end;
	result := column->at(s1len+1);
end


-- ***********************
-- UString operations

uConcat(us:UString):UString
begin
    declare aux:UString;
	aux:=new UString;
	aux.s:=self.s.concat(us.s);
	aux.c:=self.distToConf(self.confToDist() + us.confToDist(), self.s.size()+us.s.size());
	result:=aux;
end
post sizeOK: result.size() = self.size() + us.size()
post firstComponent: result.substring(1, self.size() ) = self.s
post secondComponent: result.substring(self.size() + 1, result.size() ) = us.s

uSubstring(lower:Integer, upper:Integer):UString 
begin
    declare aux:UString;
	aux:=new UString;
	aux.s:=self.s.substring(lower,upper);
	aux.c:=self.c;
	result:=aux;
end
pre validLimits: (1 <= lower) and (lower <= upper) --- and (upper <= self.size())

uEquals (us:UString) : UBoolean
begin
    declare aux:UBoolean, dist:Real, l:Integer;
	aux:=new UBoolean;
	aux.b:=true;
--	l:=self.levenshteinDist(self.s, us.s);
--	dist:=self.confToDist() + us.confToDist() + l;
--	aux.c:=self.distToConf(dist, self.size().max(us.size()));
	aux.c:=if (self.s = us.s) then self.calculateConf(us) else 1.0 - self.calculateConf(us) endif;
	result:=aux;
end

uEqualsIgnoreCase(us:UString): UBoolean
begin
	declare aux1:UString, aux2:UString;
	aux1:=self.uToUpperCase();
	aux2:=us.uToUpperCase();
	result:=aux1.uEquals(aux2);
end

uToUpperCase():UString
begin
	declare aux:UString;
	aux:=new UString;
	aux.s:=self.s.toUpperCase();
	aux.c:=self.c;
	result:=aux;
end

uToLowerCase():UString
begin
	declare aux:UString;
	aux:=new UString;
	aux.s:=self.s.toLowerCase();
	aux.c:=self.c;
	result:=aux;
end

uSize() : UInteger
begin
	declare aux:UInteger;
	aux:=new UInteger;
	aux.x:=self.s.size();
	aux.u:=self.confToDist();
	result:=aux;
end

uAt(i:Integer):UString
begin
	result.s:=self.substring(i,i);
	result.c:=self.c;
end
pre: i > 0
pre: i <= self.size()

uCharacters() : Sequence(UString)
begin
	declare aux:Sequence(UString), c:UString;
	aux:=Sequence{};
	for i in Sequence{1..self.size()} do
		c:=self.uAt(i);
		aux:=aux->append(c);
	end;
	result:=aux;
end

-- ***********
-- Conversion operations

toUBoolean() : UBoolean
begin
	declare aux:UBoolean, t:UBoolean, f:UBoolean, ts:UString, fs:UString;
	ts:=new UString;
	ts.s:='TRUE';
	ts.c:=1.0;
	fs:=new UString;
	fs.s:='FALSE';
	fs.c:=1.0;
	aux:=new UBoolean;
	
	t:=self.uEqualsIgnoreCase(ts);
	f:=self.uEqualsIgnoreCase(fs);
	
	aux.b:=true; -- normal form
		if t.c > 0.5 then aux.c:=t.c; 
	else if f.c > 0.5 then aux.c:=1-f.c;
		 else aux.c:=0.5;
		 end
	end;
	result:=aux;
end

-- ***********
-- Comparison operations

calculateConf(u:UString) : Real = self.c * u.c -- conf producto de las confianzas de cada string

lt(us:UString):UBoolean
begin
	declare aux:UBoolean;
	aux:=new UBoolean;
	aux.b:=true;
	aux.c:=if (self.s < us.s) then self.calculateConf(us) else 1.0 - self.calculateConf(us) endif;
	result:=aux;
end

gt(us:UString):UBoolean
begin
	declare aux:UBoolean;
	aux:=new UBoolean;
	aux.b:=true;
	aux.c:=if (self.s > us.s) then self.calculateConf(us) else 1.0 - self.calculateConf(us) endif;
	result:=aux;
end

le(us:UString):UBoolean
begin
	declare aux:UBoolean;
	aux:=new UBoolean;
	aux.b:=true;
	aux.c:=if (self.s <= us.s) then self.calculateConf(us) else 1.0 - self.calculateConf(us) endif;
	result:=aux;
end

ge(us:UString):UBoolean
begin
	declare aux:UBoolean;
	aux:=new UBoolean;
	aux.b:=true;
	aux.c:=if (self.s >= us.s) then self.calculateConf(us) else 1.0 - self.calculateConf(us) endif;
	result:=aux;
end

end -- UString

constraints

context UString inv validConf:
    (self.c >=0.0) and (self.c >= 1.0)

-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- UENum General (see below for one particularization

class UEnum

attributes
	values:Sequence(Tuple(literal:String,conf:Real))
	
operations
equals(ue : UEnum) : Boolean =
	-- the same literals and confs, modulo order
    self.values->asSet = ue.values->asSet

conf(lit:String):Real = 
  let L:Sequence(String) = self.values->collect(literal) in
      if L->includes(lit) then self.values->collect(conf)->at(L->indexOf(lit))
	  else 0.0
	  endif

literals():Sequence(String) = self.values->collect(literal)

uEquals(ue : UEnum) : UBoolean
  begin
    declare aux : UBoolean;
	aux:=new UBoolean;
	aux.b:=true; -- in normal form
	-- if they are equals(), then they are uEquals()
	if (self.equals(ue)) then 
		aux.c:=1.0;  
	else
	    -- boht UEnum should have the same literals 
--		if (self.literals()->asSet <> ue.literals()->asSet) then
--			aux.c:=0.0; 
--		else
--			aux.c:=1.0 - (self.literals()->iterate(l ; s : Real = 0.0 | 
--			    let x1 : Real = self.conf(l) in 
--				let x2 : Real = ue.conf(l) in
-- 				   s + (x2-x1)*(x2-x1) )/2).sqrt()
--		end
         aux.c := 1.0 - (self.literals()->union(ue.literals())->iterate(l ; s : Real = 0.0 | 
         let x1 : Real = self.conf(l) in 
         let x2 : Real = ue.conf(l) in
             s + (x2-x1)*(x2-x1))/4).sqrt();
			   
	end;
	result:=aux;
  end
end

constraints
context UEnum inv Probabilities:
  self.values->collect(conf)->sum()=1.0 and
  self.values->collect(conf)->select(c | c<0.0 or c>1.0)->isEmpty

context UEnum inv uniqueLiterals:
	self.values->size = self.values->collect(literal)->asSet()->size
   

-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- UENum Particular for colors


enum Color {RED, WHITE, BLUE, YELLOW, GREEN, BLACK }

class UColor

attributes
	values:Sequence(Tuple(literal:Color,conf:Real))
	
operations
equals(ue : UColor) : Boolean =
	-- the same literals and confs, modulo order
    self.values->asSet = ue.values->asSet

conf(lit:Color):Real = 
  let L:Sequence(Color) = self.values->collect(literal) in
      if L->includes(lit) then self.values->collect(conf)->at(L->indexOf(lit))
	  else 0.0
	  endif

literals():Sequence(Color) = self.values->collect(literal)

uEquals(ue : UColor) : UBoolean
  begin
    declare aux : UBoolean;
	aux:=new UBoolean;
	aux.b:=true; -- in normal form
	-- if they are equals(), then they are uEquals()
	if (self.equals(ue)) then 
		aux.c:=1.0;  
	else
	    -- boht UEnum should have the same literals 
--		if (self.literals()->asSet <> ue.literals()->asSet) then
--			aux.c:=0.0; 
--		else
--			aux.c:=1.0 - (self.literals()->iterate(l ; s : Real = 0.0 | 
--			    let x1 : Real = self.conf(l) in 
--				let x2 : Real = ue.conf(l) in
-- 				   s + (x2-x1)*(x2-x1) )/2).sqrt()
--		end
         aux.c := 1.0 - (self.literals()->union(ue.literals())->iterate(l ; s : Real = 0.0 | 
         let x1 : Real = self.conf(l) in 
         let x2 : Real = ue.conf(l) in
             s + (x2-x1)*(x2-x1))/4).sqrt();
			   
	end;
	result:=aux;
  end
end

constraints
context UColor inv UColorProbabilities:
  self.values->collect(conf)->sum()=1.0 and
  self.values->collect(conf)->select(c | c<0.0 or c>1.0)->isEmpty

context UColor inv UColorUniqueLiterals:
	self.values->size = self.values->collect(literal)->asSet()->size
   
-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--------------------------------------------

class UBoolean
   -- canonical form:
   -- pairs (true,c), with c the confidence that self is true
attributes
   b : Boolean 
   c : Real

operations

getC() : Real -- returns the confidence attribute
              -- it requires the UBoolean to be in normal form:
= if (not self.b) then 1-self.c else self.c endif


uNot() : UBoolean
    begin
        declare aux : UBoolean;
        aux := new UBoolean;
        aux.b:=not self.b;
        aux.c:=self.c;
        -- returns the UBoolean number in normal form:
        if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
        result:=aux;
    end
post: if self=null -- or self=invalid %USE does not implement oclIsInvalid()
      then result = self 
      else (result.b) and 
             (result.c = if self.b then 1-self.c else self.c endif)
      endif

uAnd(b : UBoolean) : UBoolean
    begin
        declare aux : UBoolean;
        if (b=null) then 
		    if (not self.toBoolean()) then -- self
			    aux := new UBoolean;
				aux.b:=self.b;
				aux.c:=self.c;
                if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
			else
			    aux:=null
			end;
		else
            aux := new UBoolean;
            aux.b:=self.b and b.b;
            aux.c:= self.c * b.c;
            -- return the UBoolean number in normal form:
            if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
		end;
        result:=aux;
    end
post: let C : Real = self.c*b.c in
      if (b=null) then
          if (not self.toBoolean()) then (result.b) and (result.c=if (self.b) then self.c else (1-self.c) endif)
		  else result=null 
		  endif
      else (result.b) and (result.c=if (self.b and b.b) then C else (1-C) endif)
	  endif
-- USE does not support the OCL 4-valued logic
-- post: let C : Real = self.c*b.c in
--      if (self.b and b.b) = null then null
--      else if (self.b and b.b) = invalid then invalid
--           else (result.b) and (result.c=if (self.b and b.b) then C else (1-C) endif)
--           endif
--      endif

uOr(b : UBoolean) : UBoolean
    begin
        declare aux : UBoolean;
        if (b=null) then 
		    if (self.toBoolean()) then -- self
			    aux := new UBoolean;
				aux.b:=self.b;
				aux.c:=self.c;
                if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
			else
			    aux:=null
			end;
		else
            aux := new UBoolean;
            aux.b:=self.b or b.b;
            aux.c:= self.c + b.c - (self.c * b.c);
            -- return the UBoolean number in normal form:
            if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
		end;
        result:=aux;
    end
post: let C : Real = self.c + b.c - (self.c * b.c) in
      if (b=null) then
          if (self.toBoolean()) then (result.b) and (result.c=if (self.b) then self.c else (1-self.c) endif)
		  else result=null 
		  endif
      else (result.b) and (result.c=if (self.b or b.b) then C else (1-C) endif)
	  endif
-- USE does not support the OCL 4-valued logic
-- post: let C : Real = (self.c + b.c - (self.c * b.c)) in
--       if (self.b or b.b) = null then null
--       else if (self.b or b.b) = invalid then invalid
--            else (result.b) and (result.c=if (self.b or b.b) then C else (1-C) endif)
--            endif
--        endif

uImplies(b : UBoolean) : UBoolean
    begin
        declare aux : UBoolean;
        if (b=null) then 
		    if (not self.toBoolean()) then -- not self
			    aux := new UBoolean;
				aux.b:=not self.b;
				aux.c:=self.c;
                if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
			else
			    aux:=null
			end;
		else
            aux := new UBoolean;
            aux.b:=self.b implies b.b;
            aux.c:= (1-self.c) + b.c - ((1-self.c) * b.c);
            -- return the UBoolean number in normal form:
            if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
		end;
        result:=aux;
	end
post: let C : Real = (1-self.c) + b.c - ((1-self.c) * b.c) in
      if (b=null) then
          if (not self.toBoolean()) then (result.b) and (result.c=if not (self.b) then self.c else (1-self.c) endif)
		  else result=null 
		  endif
      else (result.b) and (result.c=if (self.b implies b.b) then C else (1-C) endif)
	  endif
-- USE does not support the OCL 4-valued logic
-- post: let C : Real = (self.c + b.c - (self.c * b.c)) in
--        if (self.b implies b.b) = null then null
--        else if (self.b implies b.b) = invalid then invalid
--             else (result.b) and (result.c=if (self.b implies b.b) then C else (1-C) endif)
--            endif
--        endif


uEquivalent(b : UBoolean) : UBoolean
    begin
        declare aux : UBoolean;
        aux:=self.uXor(b);
        result:= aux.uNot();
   end
-- post: result = self.uXor(b).uNot()

uXor(b : UBoolean) : UBoolean
    begin
        declare aux1 : UBoolean , selfc : Real, bc : Real;
        selfc := if self.b then self.c else 1-self.c endif;
         bc := if b.b then b.c else 1-b.c endif;
         aux1 := new UBoolean;
         aux1.b := true;
         aux1.c := (selfc - bc).abs();
         result := aux1 ;
    end
 post: let selfc : Real = if self.b then self.c else 1-self.c endif in
       let bc : Real = if b.b then b.c else 1-b.c endif in  
	    (result.b) and (result.c=(selfc-bc).abs())

-- Versiones anteriores, que estaban mal
-- uEquivalent(b : UBoolean) : UBoolean
--    begin
--        declare aux1 :UBoolean, aux2 : UBoolean;
--        aux1:=self.uImplies(b);
--        aux2:=b.uImplies(self);
--        result:= aux2.uAnd(aux1);
--    end
-- -- post: result = self.uImplies(b).uAnd(b.uImplies(self))
--      
-- uXor(b : UBoolean) : UBoolean
--     begin
--        declare aux : UBoolean;
--        aux:=self.uEquivalent(b);
--        result:= aux.uNot();
--    end
-- -- post: result = self.uEquivalent(b).uNot()

equals(b : UBoolean) : Boolean = (self.b=b.b) and (self.c=b.c)

equalsC(b : UBoolean, c: Real) : Boolean = (self.b=b.b) and ((self.c-b.c).abs()<=(1-c))

distinct(b : UBoolean) : Boolean = not (self.equals(b))

uEquals(b : UBoolean) : UBoolean
    begin
        result:= self.uEquivalent(b);
    end
-- post: result = self.uEquivalent(b)

toBoolean() : Boolean = if (self.c>=0.5) then (self.b) else (not self.b) endif

-- toBoolean, but specifying the confidence threshold to decide when it is true.
toBooleanC(c:Real):Boolean = if (self.c>=c) then (self.b) else (not self.b) endif

-- Lifting operations -- Ask Martin
-- context Boolean::toUBoolean():UBoolean
--     begin
--         declare aux:UBoolean;
--         aux:=new UBoolean;
--         aux.b:=self
--         aux.c:=1.0
--         if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
--         result:=aux;
-- end

toString() : String = 'UBoolean{b='+self.b.toString()+'; c='+self.c.toString()+'}'


end

-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--
-- UBoolean, using Type_A uncertainty.
-- We assume all samples have the same size

constraints

context UBoolean_A inv SameSampleSize:
UBoolean_A.allInstances->forAll(u1,u2|u1.sample->size = u2.sample->size)

-- 
class UBoolean_A
   -- canonical form:
   -- triplets (sample,true,c), with:
   --     sample: the set of measured values obtained for self
   --     c: the confidence that self is true
   --    
attributes
   sample : Sequence(Boolean)
   b : Boolean derive: true
   c : Real derive: self.sample->count(true)/self.sample->size()

operations

-- uTrue(): UBoolean_A
--     begin
--         declare aux:UBoolean_A;
--         aux:=new UBoolean_A;
--         aux.sample:=Sequence{true,true,true,true,true,true,true,true,true,true};
--         result:=aux;
--     end
-- 
-- uFalse(): UBoolean_A
--     begin
--         declare aux:UBoolean_A;
--         aux:=new UBoolean_A;
--         aux.sample:=Sequence{false,false,false,false,false,false,false,false,false,false};
--         result:=aux;
--    end

uNot() : UBoolean_A
    begin
        declare aux : UBoolean_A;
        aux := new UBoolean_A;
        -- for i in Sequence{1..self.sample->size} do -- It doesn't work! -- we need to do a workaround:
        --    aux.sample->at(i):=self.sample->at(i); 
        -- end
        aux.sample:=self.sample;
        aux.sample:=Sequence{not self.sample->at(1)}->union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=(aux.sample->subSequence(1,i-1)->append(not self.sample->at(i)))->union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->append(not self.sample->at(self.sample->size));
        result:=aux;
    end
post: (result.b) and (result.c = if self.b then 1-self.c else self.c endif) and
      (Sequence{1..self.sample->size}->forAll(i|result.sample->at(i)=not self.sample->at(i)))

uAnd(b : UBoolean_A) : UBoolean_A
    begin
        declare aux : UBoolean_A;
        aux := new UBoolean_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)) and (b.sample->at(1))}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append(self.sample->at(i) and b.sample->at(i))->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append(self.sample->at(self.sample->size) and b.sample->at(self.sample->size));
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(self.sample->at(i) and b.sample->at(i))))

uOr(b : UBoolean_A) : UBoolean_A
    begin
        declare aux : UBoolean_A;
        aux := new UBoolean_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)) or (b.sample->at(1))}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append(self.sample->at(i) or b.sample->at(i))->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append((self.sample->at(self.sample->size)) or (b.sample->at(self.sample->size)));
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(self.sample->at(i) or b.sample->at(i))))

uImplies(b : UBoolean_A) : UBoolean_A
    begin
        declare aux : UBoolean_A;
        aux := new UBoolean_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)) implies (b.sample->at(1))}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append(self.sample->at(i) implies b.sample->at(i))->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append((self.sample->at(self.sample->size)) implies (b.sample->at(self.sample->size)));
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=self.sample->at(i) implies b.sample->at(i)))

uXor(b : UBoolean_A) : UBoolean_A
    begin
        declare aux : UBoolean_A;
        aux := new UBoolean_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)) xor (b.sample->at(1))}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append(self.sample->at(i) xor b.sample->at(i))->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append((self.sample->at(self.sample->size)) xor (b.sample->at(self.sample->size)));
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=self.sample->at(i) xor b.sample->at(i)))

uEquivalent(b : UBoolean_A) : UBoolean_A
    begin
        declare aux : UBoolean_A;
        aux := new UBoolean_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{not((self.sample->at(1)) xor (b.sample->at(1)))}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append(not(self.sample->at(i) xor b.sample->at(i)))->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append(not((self.sample->at(self.sample->size)) xor (b.sample->at(self.sample->size))));
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=not(self.sample->at(i) xor b.sample->at(i))))
-- post: result = self.uImplies(b).uAnd(b.uImplies(self)) -- or, similarly, not(self.uXor(b))
 
equals(b : UBoolean_A) : Boolean = (self.b=b.b) and (self.c=b.c)

equalsC(b : UBoolean_A, c: Real) : Boolean = (self.b=b.b) and ((self.c-b.c).abs()<=(1-c))

distinct(b : UBoolean_A) : Boolean = not (self.equals(b))

uEquals(b : UBoolean_A) : UBoolean_A
    begin
        result:= self.uEquivalent(b);
    end
-- post: result = self.uEquivalent(b)

toBoolean() : Boolean = if (self.c>=0.5) then (self.b) else (not self.b) endif

-- toBoolean, but specifying the confidence threshold to decide when it is true.
toBooleanC(c:Real):Boolean = if (self.c>=c) then (self.b) else (not self.b) endif

toString() : String = 'UBoolean_A{b='.concat(self.b.toString()).concat('; c=').concat(self.b.toString()).concat('}')


end
-- -- Lifting operations
-- context Boolean::toUBoolean_A( b :Boolean ): UBoolean_A
--     begin
--         declare aux:UBoolean_A;
--         aux:= if b then aux.uTrue() else aux.uTrue() endif;
--     end
-- post: result.sample->forAll(b | b=self)
 

-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- 
class UReal

attributes
    x : Real
    u : Real

operations

-- Operations

add(r : UReal) : UReal
    begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x + r.x;
        aux.u := if (self.u=0.0) then r.u -- self is a scalar
		         else if (r.u=0.0) then self.u -- r is a scalar, self is not
				 else (self.u*self.u + r.u*r.u).sqrt() endif endif;
        result := aux;
    end   
post: result.x=self.x + r.x and
      result.u=if (self.u=0.0) then r.u -- self is a scalar
		       else if (r.u=0.0) then self.u -- r is a scalar, self is not
			   else (self.u*self.u + r.u*r.u).sqrt() endif endif

minus(r : UReal) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x - r.x;
        aux.u := if (self.u=0.0) then r.u -- self is a scalar
		         else if (r.u=0.0) then self.u -- r is a scalar, self is not
				 else (self.u*self.u + r.u*r.u).sqrt() endif endif;
        result := aux;
    end   
post: result.x=self.x - r.x and
      result.u=if (self.u=0.0) then r.u -- self is a scalar
		       else if (r.u=0.0) then self.u -- r is a scalar, self is not
			   else (self.u*self.u + r.u*r.u).sqrt() endif endif
   
mult(r : UReal) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x*r.x;
        aux.u := (r.u*r.u*self.x*self.x + self.u*self.u*r.x*r.x).sqrt(); 
        result := aux;
     end   
post: result.x=(self.x*r.x) and
      result.u=(r.u*r.u*self.x*self.x+self.u*self.u*r.x*r.x).sqrt()
			   
    
divideBy(r : UReal) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
		-- special cases
		if (r=self) then aux.x:=1.0; aux.u:=0.0; 
		else if (r.u=0.0) then aux.x:=self.x/r.x; aux.u:=self.u/r.x; -- r is a scalar, self may be
			 else if (self.u=0.0) then -- self is a scalar, r is not
					aux.x:=self.x/r.x; aux.u:=r.u/(r.x*r.x);
				  else
					aux.x := (self.x/r.x + (self.x*r.u*r.u)/(r.x*r.x*r.x));
					aux.u := ((self.u*self.u/r.x) + 
							 ((r.u*r.u*self.x*self.x)/(r.x*r.x*r.x*r.x))).sqrt();
				  end;
			 end;
		end;
        result := aux;
    end   
post: result.x=if (r=self) then 1.0 
               else if (r.u=0.0) then self.x/r.x -- r is a scalar, self may be
			        else if (self.u=0.0) then self.x/r.x -- self is a scalar, r is not
					     else (self.x/r.x + (self.x*r.u*r.u)/(r.x*r.x*r.x)) 
						 endif
					endif 
			   endif
	  and
      result.u=if (r=self) then 0.0 
               else if (r.u=0.0) then self.u/r.x -- r is a scalar, self may be
			        else if (self.u=0.0) then r.u/(r.x*r.x) -- self is a scalar, r is not
					     else ((self.u*self.u/r.x) + ((r.u*r.u*self.x*self.x)/(r.x*r.x*r.x*r.x))).sqrt() 
						 endif
					endif 
			   endif
				 
--- CORRELATED VARIABLES WITH KNOWN COVARIANCE
-- suffix "c" added to their names because USE does not supports polimorphysm

addc(r : UReal, cov: Real) : UReal -- with covariance
    begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x + r.x;
        aux.u := if (self.u=0.0) then r.u -- self is a scalar
		         else if (r.u=0.0) then self.u -- r is a scalar, self is not
				 else (self.u*self.u + r.u*r.u + 2*cov).sqrt() endif endif;
        result := aux;
    end   
post: result.x=self.x + r.x and
      result.u=if (self.u=0.0) then r.u -- self is a scalar
		       else if (r.u=0.0) then self.u -- r is a scalar, self is not
			   else (self.u*self.u + r.u*r.u + 2*cov).sqrt() endif endif

minusc(r : UReal, cov : Real) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x - r.x;
        aux.u := if (self.u=0.0) then r.u -- self is a scalar
		         else if (r.u=0.0) then self.u -- r is a scalar, self is not
				 else (self.u*self.u + r.u*r.u - 2*cov).sqrt() endif endif;
        result := aux;
    end   
post: result.x=self.x - r.x and
      result.u=if (self.u=0.0) then r.u -- self is a scalar
		       else if (r.u=0.0) then self.u -- r is a scalar, self is not
			   else (self.u*self.u + r.u*r.u - 2*cov).sqrt() endif endif
   
multc(r : UReal, cov:Real) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x*r.x;
        aux.u := (r.u*r.u*self.x*self.x + self.u*self.u*r.x*r.x + 2*self.x*r.x*cov).sqrt();
        result := aux;
     end   
post: result.x=(self.x*r.x) and
      result.u=(r.u*r.u*self.x*self.x+self.u*self.u*r.x*r.x + 2*self.x*r.x*cov).sqrt()
			   
    
divideByc(r : UReal, cov:Real) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
		-- special cases
		if (r=self) then aux.x:=1.0; aux.u:=0.0; 
		else if (r.u=0.0) then aux.x:=self.x/r.x; aux.u:=self.u/r.x; -- r is a scalar, self may be
			 else if (self.u=0.0) then -- self is a scalar, r is not
					aux.x:=self.x/r.x; aux.u:=r.u/(r.x*r.x);
				  else
					aux.x := (self.x/r.x + (self.x*r.u*r.u)/(r.x*r.x*r.x));
					aux.u := ((self.u*self.u/r.x.abs()) + 
							   ((r.u*r.u*self.x*self.x)/(r.x*r.x*r.x*r.x)) -
							   self.x*cov/((r.x*r.x*r.x).abs()) 
							  ).sqrt();
				  end;
			 end;
		end;
        result := aux;
    end   
post: result.x=if (r=self) then 1.0 
               else if (r.u=0.0) then self.x/r.x -- r is a scalar, self may be
			        else if (self.u=0.0) then self.x/r.x -- self is a scalar, r is not
					     else (self.x/r.x + (self.x*r.u*r.u)/(r.x*r.x*r.x)) 
						 endif
					endif 
			   endif
	  and
      result.u=if (r=self) then 0.0 
               else if (r.u=0.0) then self.u/r.x -- r is a scalar, self may be
			        else if (self.u=0.0) then r.u/(r.x*r.x) -- self is a scalar, r is not
					     else ((self.u*self.u/r.x.abs()) + 
							   ((r.u*r.u*self.x*self.x)/(r.x*r.x*r.x*r.x)) -
							   self.x*cov/((r.x*r.x*r.x).abs()) 
							  ).sqrt()
						 endif
					endif 
			   endif


-- TRIGONOMETRIC OPERATIONS  
sin() :UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.sin();
        aux.u := (self.x.cos() * self.u).abs() ;
        result := aux;
    end   
post: result.x=self.x.sin() and
      result.u=(self.x.cos()*self.u).abs()

cos() :UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.cos();
        aux.u := (self.x.sin() * self.u).abs() ;
        result := aux;
    end   
post: result.x=self.x.cos() and
      result.u=(self.x.sin()*self.u).abs()
    
tan():UReal
    begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.tan();
        aux.u := self.u / (self.x.cos()*self.x.cos()) ;
        result := aux;
    end
post: result.x=self.x.tan() and
      result.u= self.u / (self.x.cos()*self.x.cos())

	
atan() :UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.atan();
        aux.u := self.u / (1 + self.x*self.x) ;
        result := aux;
    end   
post: result.x=self.x.atan() and
      result.u=self.u / (1 + self.x*self.x)

asin() :UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.asin();
        aux.u := self.u / ((1 - self.x*self.x).sqrt()) ;
        result := aux;
    end   
post: result.x=self.x.asin() and
      result.u=self.u / ((1 - self.x*self.x).sqrt())

acos() :UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.acos();
        aux.u := self.u / ((1 - self.x*self.x).sqrt()) ;
        result := aux;
    end   
post: result.x=self.x.acos() and
      result.u=self.u / ((1 - self.x*self.x).sqrt())

   
abs() : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := (self.x).abs();
        aux.u := self.u;
        result := aux;
    end 
post: result.x=self.x.abs() and
      result.u=self.u 
	
    
neg() : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := -self.x;
        aux.u := self.u;
        result := aux;
    end   
post: result.x=-self.x and
      result.u=self.u 

floor() : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.floor();
        aux.u := self.u;
        result := aux;
    end   
post: result.x=self.x.floor() and
      result.u=self.u 
    
round() : UReal
    begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.round();
        aux.u := self.u;
        result := aux;
    end   
post: result.x=self.x.round() and
      result.u=self.u 
    
inverse() : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := 1.0;
        aux.u := 0.0;
        result := aux.divideBy(self);
    end   
    
power (s : Real) : UReal
     begin
        declare aux : UReal;
        aux := new UReal;
        aux.x := self.x.power(s); -- + ((s*(s-1))/2)*self.x.power(s-2)*(self.u*self.u);
        aux.u := s*self.u*self.x.power(s-1);
        result := aux;
    end   
post: result.x=self.x.power(s) 
               -- + ((s*(s-1))/2)*self.x.power(s-2)*(self.u*self.u) 
			  and result.u=s*self.u*self.x.power(s-1) 
    
sqrt() : UReal 
    begin
        declare aux : UReal;
		-- aux:=self.power(0.5);
        aux.x := self.x.sqrt(); -- (self.u*self.u*self.x*self.x*self.x)/(8*self.x.sqrt());
        aux.u := self.u/(2*self.x.sqrt());
        result := aux;
    end
post: result.x=self.x.sqrt() and -- (self.u*self.u*self.x*self.x*self.x)/(8*self.x.sqrt()) and
      result.u=self.u/(2*self.x.sqrt())    
	  
-- comparison operations

equals(r : UReal) : Boolean 
   = (self.x - self.u).max(r.x - r.u) <= 
         (self.x + self.u).min(r.x + r.u)
   
distinct(r : UReal) : Boolean
    = not self.equals(r) 

compareTo(r : UReal) : Integer
    = if self.equals(r) then 0
      else if self.lt(r) then -1 
           else 1 
           endif 
      endif

lt(r : UReal) : Boolean
   = (self.x<r.x) and ((self.x + self.u)<(r.x - r.u)) 

le(r : UReal) : Boolean 
   = self.lt(r) or self.equals(r)
    
gt(r : UReal) : Boolean
   = not self.le(r) 

ge(r : UReal) : Boolean 
   = not self.lt(r)

max(r : UReal) : UReal
    = if r.lt(self) then self else r endif
   
min(r : UReal) : UReal
    = if r.lt(self) then r else self endif


-- Comparisons with Zero=UReal(0,0)
equalsZero() : Boolean 
   = (self.x - self.u).max(0.0) <= (self.x + self.u).min(0.0)

ltZero() : Boolean
   = ((self.x + self.u)<0.0) 

leZero() : Boolean 
   = self.ltZero() or self.equalsZero()
    
gtZero() : Boolean
   = not self.leZero() 

geZero() : Boolean 
   = not self.ltZero()

   
-- Fuzzy comparison operations

-- aux operation
calculate(r : UReal) :Tuple(lt:Real,eq:Real,gt:Real)
begin
            declare m1 : Real, m2 : Real, s1 : Real, s2 : Real, crossing1 : Real, crossing2 : Real, 
                    r1 : Real, r2 : Real, c1 : Real, c2 : Real,
                    aux : Tuple(lt:Real,eq:Real,gt:Real), swap : Boolean;
            if (self.x <= r.x) then
                m1:=self.x; m2:=r.x; s1:=self.u; s2:=r.u; swap:=false;
            else
                m2:=self.x; m1:=r.x; s2:=self.u; s1:=r.u; swap:=true;
            end;
            if (s1=0.0) and (s2=0.0) then  -- Real numbers
                if (m1=m2) then 
                    aux:=Tuple{lt:0.0,eq:1.0,gt:0.0};
                else
                    if (m1<m2) then
                        aux:=Tuple{lt:1.0,eq:0.0,gt:0.0};
                    else
                        aux:=Tuple{lt:0.0,eq:0.0,gt:1.0};
                    end
                end
            else 
           		if ((s1=0.0)) then --- s1 is degenerated, s2 is not
                   aux:=Tuple{lt:1.0-m1.cdf(m2,s2),eq:0.0,gt:m1.cdf(m2,s2)};
                else
                    if ((s2=0.0))  then  --- s2 is degenerated, s1 is not
                        aux:=Tuple{lt:m2.cdf(m1,s1),eq:0.0,gt:1.0-m2.cdf(m1,s1)};
                    else --- none of the two numbers are degenerated. This is where the fun starts...
                        if (s1=s2) then
                            crossing1 := (m1+m2)/2;
                            aux:=Tuple{
                        		 lt:crossing1.cdf(m1,s1)-crossing1.cdf(m2,s2),
			                     eq:crossing1.cdf(m2,s2)+1.0-crossing1.cdf(m1,s1),
			                     gt:0.0 -- 1.0-crossing1.cdf(m2,s2)-(1.0-crossing1.cdf(m1,s1))
                            };
                        else
                            r1:=(s2/s1).log();
                            r2:=((m1-m2)*(m1-m2)-2.0*(s1*s1-s2*s2)*r1).sqrt();
                            crossing1:= -(-m2*s1*s1 + m1*s2*s2 + s1*s2*r2 )/(s1*s1 - s2*s2);	
                            crossing2:=  ( m2*s1*s1 - m1*s2*s2 + s1*s2*r2 )/(s1*s1 - s2*s2);
                            c1:=crossing1.min(crossing2);
                            c2:=crossing1.max(crossing2);
                            if (s1<s2) then
                                aux:=Tuple{
                                    lt:1.0-c2.cdf(m2,s2)-(1.0-c2.cdf(m1,s1)),
                                    eq:c1.cdf(m1,s1) + (1.0-c2.cdf(m1,s1)) + c2.cdf(m2,s2) - c1.cdf(m2,s2),
                                    gt:c1.cdf(m2,s2)-c1.cdf(m1,s1)
                                };
                            else
                                aux:=Tuple{
                                    lt:c1.cdf(m1,s1)-c1.cdf(m2,s2),
                                    eq:c1.cdf(m2,s2) + (1.0-c2.cdf(m2,s2)) + c2.cdf(m1,s1) - c1.cdf(m1,s1),
                                    gt:1.0-c2.cdf(m1,s1)-(1.0-c2.cdf(m2,s2))
                                };
                            end
                        end --- end of fun
                    end
                end            
            end;
            if (swap) then 
                result:=Tuple{lt:aux.gt,eq:aux.eq,gt:aux.lt};
            else
                result:=Tuple{lt:aux.lt,eq:aux.eq,gt:aux.gt};
            end
end -- calculate

-- fuzzy operations

uEquals(r : UReal) : UBoolean
    begin
       declare aux : Tuple(lt:Real,eq:Real,gt:Real), aux2 : UBoolean;		
       aux2:=new UBoolean;
       aux:=self.calculate(r);
       aux2.b := true;
       aux2.c := aux.eq;
       result:=aux2;
    end

uDistinct(r : UReal) : UBoolean
    begin
        declare aux : UBoolean;
        aux := self.uEquals(r);
        result := aux.uNot();
    end

uLt(r : UReal) : UBoolean
     begin
       declare aux : Tuple(lt:Real,eq:Real,gt:Real), aux2 : UBoolean;
       aux2:=new UBoolean;
       aux:=self.calculate(r);
       aux2.b:=true;
       aux2.c:=aux.lt;
       result := aux2;
    end

uLe(r : UReal) : UBoolean 
     begin
       declare aux : Tuple(lt:Real,eq:Real,gt:Real), aux2 : UBoolean;
       aux2:=new UBoolean;
       aux:=self.calculate(r);
       aux2.b:=true;
       aux2.c:=aux.lt+aux.eq;
       result := aux2;
    end
   
uGt(r : UReal) : UBoolean
     begin
       declare aux : Tuple(lt:Real,eq:Real,gt:Real), aux2 : UBoolean;
       aux2:=new UBoolean;
       aux:=self.calculate(r);
       aux2.b:=true;
       aux2.c:=aux.gt;
       result := aux2;
    end

uGe(r : UReal) : UBoolean 
     begin
       declare aux : Tuple(lt:Real,eq:Real,gt:Real), aux2 : UBoolean;
       aux2:=new UBoolean;
       aux:=self.calculate(r);
       aux2.b:=true;
       aux2.c:=aux.gt+aux.eq;
       result := aux2;
    end

-- comparisons with Zero

uEqualsZero() : UBoolean
    begin
       declare aux : Tuple(lt:Real,eq:Real,gt:Real), r:UReal, aux2 : UBoolean;
       r:=new UReal;
       aux2:=new UBoolean;
       r.x:=0.0;
       r.u:=0.0;		
       aux:=self.calculate(r);
       aux2.b:=true;
       aux2.c:=aux.eq;
       result := aux2;
    end

uLtZero() : UBoolean
     begin
        declare aux : Tuple(lt:Real,eq:Real,gt:Real), r:UReal, aux2 : UBoolean;
       aux2:=new UBoolean;
       r:=new UReal;
       r.x:=0.0;
       r.u:=0.0;		
       aux:=self.calculate(r);
       aux2.b:=true;
       aux2.c:=aux.lt;
       result := aux2;
    end

uLeZero() : UBoolean 
     begin
       declare aux : Tuple(lt:Real,eq:Real,gt:Real), r:UReal, aux2 : UBoolean;
       aux2:=new UBoolean;
       r:=new UReal;
       r.x:=0.0;
       r.u:=0.0;		
       aux:=self.calculate(r);
       aux2.b:=true;
       aux2.c:=aux.lt+aux.eq;
       result := aux2;
    end
   
uGtZero() : UBoolean
     begin
       declare aux : Tuple(lt:Real,eq:Real,gt:Real), r:UReal, aux2 : UBoolean;
       aux2:=new UBoolean;
       r:=new UReal;
       r.x:=0.0;
       r.u:=0.0;		
       aux:=self.calculate(r);
       aux2.b:=true;
       aux2.c:=aux.gt;
       result := aux2;
 
    end

uGeZero() : UBoolean 
     begin
       declare aux : Tuple(lt:Real,eq:Real,gt:Real), r:UReal, aux2 : UBoolean;
       aux2:=new UBoolean;
       r:=new UReal;
       r.x:=0.0;
       r.u:=0.0;		
       aux:=self.calculate(r);
       aux2.b:=true;
       aux2.c:=aux.gt+aux.eq;
       result := aux2;
    end

-- conversion operations
toInteger() : Integer = self.x.floor() 

toUInteger() : UInteger
    begin
        declare aux:UInteger;
        aux:=new UInteger;
        aux.x:=self.x.floor(); 
        aux.u:=((self.u*self.u)+(self.x-aux.x)*(self.x-aux.x)).sqrt;
        result:=aux;
    end

toBestUInteger() : UInteger
    begin
        declare aux:UInteger;
        aux:=new UInteger;
        aux.x:=self.x.round(); 
        aux.u:=((self.u*self.u)+(self.x-aux.x)*(self.x-aux.x)).sqrt;
        result:=aux;
    end


toUUnlimitedNatural() : UUnlimitedNatural
    begin
        declare aux:UUnlimitedNatural;
        aux:=new UUnlimitedNatural;
        aux.x:=self.x.floor(); 
        aux.u:=((self.u*self.u)+(self.x-aux.x)*(self.x-aux.x)).sqrt;
        result:=aux;
    end

toBestUUnlimitedNatural() : UUnlimitedNatural
    begin
        declare aux:UUnlimitedNatural;
        aux:=new UUnlimitedNatural;
        aux.x:=self.x.round(); 
        aux.u:=((self.u*self.u)+(self.x-aux.x)*(self.x-aux.x)).sqrt;
        result:=aux;
    end


toReal() : Real = self.x

toString() : String = 'UReal{x='.concat(self.x.toString()).concat('; u=').concat(self.u.toString()).concat('}')

end -- of class UReal

-- -- Lifting operations
-- context Real::toUReal():UReal
--     begin
--         declare aux:UReal;
--         aux:=new UReal;
--         aux.x:=self;
--         aux.u:=0.0;
--         result:=aux;
--     end
--     post: (result.x = self) and (result.u=0.0)


-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--
-- UReal, using Type_A uncertainty.
-- We assume all samples have the same size

constraints

context UReal_A inv SameSampleSize:
UReal_A.allInstances->forAll(u1,u2|u1.sample->size = u2.sample->size)

-- 
class UReal_A
attributes
   sample : Sequence(Real)
   x : Real derive: self.sample->avg()
   u : Real derive: self.sample->stdDev()

operations
add(r : UReal_A) : UReal_A
    begin
        declare aux : UReal_A;
        aux := new UReal_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)) + (r.sample->at(1))}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append(self.sample->at(i) + r.sample->at(i))->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append(self.sample->at(self.sample->size) + r.sample->at(self.sample->size));
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(self.sample->at(i) + r.sample->at(i))))

minus(r : UReal_A) : UReal_A
    begin
        declare aux : UReal_A;
        aux := new UReal_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)) - (r.sample->at(1))}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append(self.sample->at(i) - r.sample->at(i))->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append(self.sample->at(self.sample->size) - r.sample->at(self.sample->size));
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(self.sample->at(i) - r.sample->at(i))))

mult(r : UReal_A) : UReal_A
    begin
        declare aux : UReal_A;
        aux := new UReal_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)) * (r.sample->at(1))}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append(self.sample->at(i) * r.sample->at(i))->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append(self.sample->at(self.sample->size) * r.sample->at(self.sample->size));
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(self.sample->at(i) * r.sample->at(i))))

divideBy(r : UReal_A) : UReal_A
    begin
        declare aux : UReal_A;
        aux := new UReal_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{if r.sample->at(1)=0 then 0 else (self.sample->at(1)) / (r.sample->at(1)) endif}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append(if r.sample->at(i)=0 then 0 else self.sample->at(i) / r.sample->at(i) endif)->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append(if r.sample->at(self.sample->size)=0 then 0 else self.sample->at(self.sample->size) / r.sample->at(self.sample->size) endif);
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(if r.sample->at(i)=0 then 0 else self.sample->at(i) / r.sample->at(i) endif)))

neg() : UReal_A
    begin
        declare aux : UReal_A;
        aux := new UReal_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{-(self.sample->at(1))}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append(-self.sample->at(i))->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append(-self.sample->at(self.sample->size));
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(-self.sample->at(i))))

abs() : UReal_A
    begin
        declare aux : UReal_A;
        aux := new UReal_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)).abs()}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append((self.sample->at(i)).abs())->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append((self.sample->at(self.sample->size)).abs());
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(self.sample->at(i)).abs()))
		
floor() : UReal_A
    begin
        declare aux : UReal_A;
        aux := new UReal_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)).floor()}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append((self.sample->at(i)).floor())->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append((self.sample->at(self.sample->size)).floor());
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(self.sample->at(i)).floor()))
		
round() : UReal_A
    begin
        declare aux : UReal_A;
        aux := new UReal_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)).round()}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append((self.sample->at(i)).round())->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append((self.sample->at(self.sample->size)).round());
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(self.sample->at(i)).round()))
		
sqrt() : UReal_A
    begin
        declare aux : UReal_A;
        aux := new UReal_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)).sqrt()}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append((self.sample->at(i)).sqrt())->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append((self.sample->at(self.sample->size)).sqrt());
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(self.sample->at(i)).round()))
		
power(s:Real) : UReal_A
    begin
        declare aux : UReal_A;
        aux := new UReal_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)).power(s)}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append((self.sample->at(i)).power(s))->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append((self.sample->at(self.sample->size)).power(s));
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(self.sample->at(i)).power(s)))

-- COMPARISON OPERATIONS
equals(r : UReal_A) : Boolean 
   = (self.x - self.u).max(r.x - r.u) <= 
         (self.x + self.u).min(r.x + r.u)
distinct(r : UReal_A) : Boolean
    = not self.equals(r) 
compareTo(r : UReal_A) : Integer
    = if self.equals(r) then 0
      else if self.lt(r) then -1 
           else 1 endif endif
lt(r : UReal_A) : Boolean
   = (self.x<r.x) and ((self.x + self.u)<(r.x - r.u)) 
le(r : UReal_A) : Boolean 
   = self.lt(r) or self.equals(r)
gt(r : UReal_A) : Boolean
   = not self.le(r) 
ge(r : UReal_A) : Boolean 
   = not self.lt(r)
max(r : UReal_A) : UReal_A
    = if r.lt(self) then self else r endif
min(r : UReal_A) : UReal_A
    = if r.lt(self) then r else self endif

-- TRIGONOMETRIC OPERATIONS		
sin() : UReal_A
    begin
        declare aux : UReal_A;
        aux := new UReal_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)).sin()}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append((self.sample->at(i)).sin())->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append((self.sample->at(self.sample->size)).sin());
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(self.sample->at(i)).sin()))
	
cos() : UReal_A
    begin
        declare aux : UReal_A;
        aux := new UReal_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)).cos()}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append((self.sample->at(i)).cos())->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append((self.sample->at(self.sample->size)).cos());
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(self.sample->at(i)).cos()))
	
tan() : UReal_A
    begin
        declare aux : UReal_A;
        aux := new UReal_A;
        aux.sample:=self.sample;
        aux.sample:=Sequence{(self.sample->at(1)).tan()}->
                     union(aux.sample->subSequence(2,self.sample->size));
        for i in Sequence{2..self.sample->size-1} do
            aux.sample:=aux.sample->subSequence(1,i-1)->
                        append((self.sample->at(i)).tan())->
                        union(aux.sample->subSequence(i+1,self.sample->size));
        end;
        aux.sample:=aux.sample->subSequence(1,self.sample->size-1)->
                    append((self.sample->at(self.sample->size)).tan());
        result:=aux;
    end
post: (Sequence{1..self.sample->size}->
        forAll(i|result.sample->at(i)=(self.sample->at(i)).tan()))
	
toInteger() : Integer = self.x.floor() 

toUInteger() : UInteger
    begin
        declare aux:UInteger;
        aux:=new UInteger;
        aux.x:=self.x.floor(); 
        aux.u:=((self.u*self.u)+(self.x-aux.x)*(self.x-aux.x)).sqrt;
        result:=aux;
    end

toBestUInteger() : UInteger
    begin
        declare aux:UInteger;
        aux:=new UInteger;
        aux.x:=self.x.round(); 
        aux.u:=((self.u*self.u)+(self.x-aux.x)*(self.x-aux.x)).sqrt;
        result:=aux;
    end


toUUnlimitedNatural() : UUnlimitedNatural
    begin
        declare aux:UUnlimitedNatural;
        aux:=new UUnlimitedNatural;
        aux.x:=self.x.floor(); 
        aux.u:=((self.u*self.u)+(self.x-aux.x)*(self.x-aux.x)).sqrt;
        result:=aux;
    end

toBestUUnlimitedNatural() : UUnlimitedNatural
    begin
        declare aux:UUnlimitedNatural;
        aux:=new UUnlimitedNatural;
        aux.x:=self.x.round(); 
        aux.u:=((self.u*self.u)+(self.x-aux.x)*(self.x-aux.x)).sqrt;
        result:=aux;
    end


toReal() : Real = self.x

toString() : String = 'UReal_A{x='.concat(self.x.toString()).concat('; u=').concat(self.u.toString()).concat('}')

		
end

-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- 
class UInteger

attributes
    x : Integer
    u : Real

operations
-- Assume normally distributed uncertainties and independent variables

add(r : UInteger) : UInteger
    begin
        declare aux : UInteger;
        aux := new UInteger;
        aux.x := self.x + r.x;
        aux.u := (self.u*self.u + r.u*r.u).sqrt();
        result := aux;
    end   
post: (result.x = self.x + r.x) and (result.u=(self.u*self.u + r.u*r.u).sqrt()) 

minus(r : UInteger) : UInteger
     begin
        declare aux : UInteger;
        aux := new UInteger;
        aux.x := self.x - r.x;
        aux.u := (self.u*self.u + r.u*r.u).sqrt();
        result := aux;
    end   
post: (result.x = self.x - r.x) and (result.u=(self.u*self.u + r.u*r.u).sqrt()) 
   
mult(r : UInteger) : UInteger
     begin
        declare aux : UInteger;
        aux := new UInteger;
        aux.x := self.x*r.x;
        aux.u := (r.u*r.u*self.x*self.x + self.u*self.u*r.x*r.x).sqrt();
        result := aux;
     end   
post: (result.x = self.x * r.x) and 
      (result.u=(r.u*r.u*self.x*self.x + self.u*self.u*r.x*r.x).sqrt()) 
    
divideBy(r : UInteger) : UInteger
     begin
        declare r1 : UReal, r2 : UReal, r3 : UReal;
        r1 := self.toUReal();
        r2 := r.toUReal();
        r3:=r1.divideBy(r2);
        result:=r3.toUInteger();
    end 
-- post: result = self.toUReal().divideBy(r.toUReal()).toUInteger();  

divideByR(r : UInteger) : UReal
     begin
        declare r1 : UReal, r2 : UReal;
        r1 := self.toUReal();
        r2 := r.toUReal();
        result:=r1.divideBy(r2);
    end   
-- post: result = self.toUReal().divideBy(r.toUReal());  

mod(r : UInteger) : UInteger
     begin
        declare r1 : UReal, r2 : UReal, r3 : UReal, r4 : UReal, r5 : UReal, r6 : UReal;
        r1 := self.toUReal();
        r2 := r.toUReal();
        r3:=r1.divideBy(r2);
        r4:=r3.floor();
        r5:=r4.mult(r2);
        r6:=r1.minus(r5);
        result:=r6.toUInteger();
    end   


abs() : UInteger
     begin
        declare aux : UInteger;
        aux := new UInteger;
        aux.x := self.x.abs();
        aux.u := self.u;
        result := aux;
    end   
post: result.x = (self.x.abs()) and (result.u=self.u)
    
neg() : UInteger
     begin
        declare aux : UInteger;
        aux := new UInteger;
        aux.x := -self.x;
        aux.u := self.u;
        result := aux;
    end   
post: result.x = (-self.x) and (result.u=self.u)


inverse() : UInteger
     begin
        declare r1 : UReal, r2 : UReal;
        r1 := self.toUReal();
        r2:=r1.inverse();
        result:=r2.toUInteger();
    end   
-- post: result = self.toUReal().inverse().toUInteger()
    
power (s : Real) : UInteger
     begin
        declare r1 : UReal, r2 : UReal;
        r1 := self.toUReal();
        r2:=r1.power(s);
        result:=r2.toUInteger();
    end   
-- post: result = self.toUReal().power(s).toUInteger()
    
sqrt() : UInteger 
    begin
        declare aux : UInteger;
        aux := self.power(0.5);
        result := aux;
    end
-- post: result = self.power(0.5)  

-- comparison operations

equals(r : UInteger) : Boolean 
   = (self.x - self.u).max(r.x - r.u) <= 
         (self.x + self.u).min(r.x + r.u)
   
distinct(r : UInteger) : Boolean
    = not self.equals(r) 

compareTo(r : UInteger) : Integer
    = if self.equals(r) then 0
      else if self.lt(r) then -1 
           else 1 
           endif 
      endif

lt(r : UInteger) : Boolean
   = (self.x<r.x) and ((self.x + self.u)<(r.x - r.u)) 

le(r : UInteger) : Boolean 
   = self.lt(r) or self.equals(r)
    
gt(r : UInteger) : Boolean
   = not self.le(r) 

ge(r : UInteger) : Boolean 
   = not self.lt(r)

max(r : UInteger) : UInteger
    = if r.lt(self) then self else r endif
   
min(r : UInteger) : UInteger
    = if r.lt(self) then r else self endif

-- comparison operations with Zero=UInteger(0,0.0)

equalsZero() : Boolean 
   = (self.x - self.u).max(0.0) <= (self.x + self.u).min(0.0)
   
ltZero() : Boolean
   = (self.x + self.u)<0 

leZero() : Boolean 
   = self.ltZero() or self.equalsZero()
    
gtZero() : Boolean
   = not self.leZero() 

geZero() : Boolean 
   = not self.ltZero()


-- Fuzzy comparison operations

uEquals(r : UInteger) : UBoolean
    begin
       declare aux1 : UReal, aux2:UReal;
       aux1:=self.toUReal();
       aux2:=r.toUReal();
       result:=aux1.uEquals(aux2);
    end
-- post: result = self.toUReal().uEquals(r.toUReal())

uDistinct(r : UInteger) : UBoolean
    begin
       declare aux1 : UReal, aux2:UReal;
       aux1:=self.toUReal();
       aux2:=r.toUReal();
       result:=aux1.uDistinct(aux2);
    end
-- post: result = self.toUReal().uDistinct(r.toUReal())

uLt(r : UInteger) : UBoolean
    begin
       declare aux1 : UReal, aux2:UReal;
       aux1:=self.toUReal();
       aux2:=r.toUReal();
       result:=aux1.uLt(aux2);
    end
-- post: result = self.toUReal().uLt(r.toUReal())

uLe(r : UInteger) : UBoolean 
    begin
       declare aux1 : UReal, aux2:UReal;
       aux1:=self.toUReal();
       aux2:=r.toUReal();
       result:=aux1.uLe(aux2);
    end
-- post: result = self.toUReal().uLe(r.toUReal())   
uGt(r : UInteger) : UBoolean
    begin
       declare aux1 : UReal, aux2:UReal;
       aux1:=self.toUReal();
       aux2:=r.toUReal();
       result:=aux1.uGt(aux2);
    end
-- post: result = self.toUReal().uGt(r.toUReal())

uGe(r : UInteger) : UBoolean 
    begin
       declare aux1 : UReal, aux2:UReal;
       aux1:=self.toUReal();
       aux2:=r.toUReal();
       result:=aux1.uGe(aux2);
    end
-- post: result = self.toUReal().uGe(r.toUReal())

-- Fuzzy comparison operations with Zero=UInteger(0,0.0)

uEqualsZero() : UBoolean
    begin
       declare aux1 : UReal, aux2:UReal, r : UInteger;
       r:=new UInteger;
       r.x:=0;
       r.u:=0.0;
       aux1:=self.toUReal();
       aux2:=r.toUReal();
       result:=aux1.uEquals(aux2);
    end
-- post: result = self.toUReal().uEquals(r.toUReal())

uLtZero() : UBoolean
    begin
       declare aux1 : UReal, aux2:UReal, r : UInteger;
       r:=new UInteger;
       r.x:=0;
       r.u:=0.0;
       aux1:=self.toUReal();
       aux2:=r.toUReal();
       result:=aux1.uLt(aux2);
    end
-- post: result = self.toUReal().uLt(r.toUReal())

uLeZero() : UBoolean 
    begin
       declare aux1 : UReal, aux2:UReal, r : UInteger;
       r:=new UInteger;
       r.x:=0;
       r.u:=0.0;
       aux1:=self.toUReal();
       aux2:=r.toUReal();
       result:=aux1.uLe(aux2);
    end
-- post: result = self.toUReal().uLe(r.toUReal())   
uGtZero() : UBoolean
    begin
       declare aux1 : UReal, aux2:UReal, r : UInteger;
       r:=new UInteger;
       r.x:=0;
       r.u:=0.0;
       aux1:=self.toUReal();
       aux2:=r.toUReal();
       result:=aux1.uGt(aux2);
    end
-- post: result = self.toUReal().uGt(r.toUReal())

uGeZero() : UBoolean 
    begin
       declare aux1 : UReal, aux2:UReal, r : UInteger;
       r:=new UInteger;
       r.x:=0;
       r.u:=0.0;
       aux1:=self.toUReal();
       aux2:=r.toUReal();
       result:=aux1.uGe(aux2);
    end
-- post: result = self.toUReal().uGe(r.toUReal())


-- conversion operations

toUReal() : UReal
    begin
       declare aux : UReal;
       aux:=new UReal;
       aux.x:=self.x;
       aux.u:=self.u;
       result:=aux;
    end
post: result.x=self.x and result.u=self.u

toInteger() : Integer = self.x

toReal() : Real = self.x

toString() : String = 'UInteger{x='.concat(self.x.toString()).concat('; u=').concat(self.u.toString()).concat('}')
   
 
end

-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- 
class UUnlimitedNatural

attributes
    x : Integer -- '*' is represented by -1
    u : Real   

operations
-- Assume normally distributed uncertainties and independent variables

add(r : UUnlimitedNatural) : UUnlimitedNatural
    begin
        declare aux : UUnlimitedNatural;
        aux := new UUnlimitedNatural;
        aux.x := self.x + r.x;
        aux.u := (self.u*self.u + r.u*r.u).sqrt();
        result := aux;
    end   
post: (self.x<>-1 and r.x<>-1) implies (result.x = self.x + r.x) and (result.u=(self.u*self.u + r.u*r.u).sqrt()) 
       -- otherwise result is oclInvalid
         
--No minus operation defined for UUnlimitedNatural
-- minus(r : UUnlimitedNatural) : UUnlimitedNatural
--      begin
--     end   
-- post: (result.x = self.x - r.x) and (result.u=(self.u*self.u + r.u*r.u).sqrt()) 
   
mult(r : UUnlimitedNatural) : UUnlimitedNatural
     begin
        declare aux : UUnlimitedNatural;
        aux := new UUnlimitedNatural;
        aux.x := self.x*r.x;
        aux.u := (r.u*r.u*self.x*self.x + self.u*self.u*r.x*r.x).sqrt();
        result := aux;
     end   
post: (self.x<>-1 and r.x<>-1) implies (result.x = self.x * r.x) and 
                                     (result.u=(r.u*r.u*self.x*self.x + self.u*self.u*r.x*r.x).sqrt()) 
    
divideBy(r : UUnlimitedNatural) : UUnlimitedNatural
     begin
        declare r1 : UReal, r2 : UReal, r3 : UReal;
        r1 := self.toUReal();
        r2 := r.toUReal();
        r3:=r1.divideBy(r2);
        result:=r3.toUUnlimitedNatural();
    end 
-- post: result = self.toUReal().divideBy(r.toUReal()).toUInteger();  

divideByR(r : UUnlimitedNatural) : UReal
     begin
        declare r1 : UReal, r2 : UReal;
        r1 := self.toUReal();
        r2 := r.toUReal();
        result:=r1.divideBy(r2);
    end   
-- post: result = self.toUReal().divideBy(r.toUReal());  

mod(r : UUnlimitedNatural) : UUnlimitedNatural
     begin
        declare r1 : UReal, r2 : UReal, r3 : UReal, r4 : UReal, r5 : UReal, r6 : UReal;
        r1 := self.toUReal();
        r2 := r.toUReal();
        r3:=r1.divideBy(r2);
        r4:=r3.floor();
        r5:=r4.mult(r2);
        r6 := r1.minus(r5);
        result:=r6.toUUnlimitedNatural();
    end   

-- comparison operations

equals(r : UUnlimitedNatural) : Boolean 
   = if (self.x<>-1) and (r.x<>-1) then 
           (self.x - self.u).max(r.x - r.u) <= 
                 (self.x + self.u).min(r.x + r.u)
     else (self.x=-1) and (r.x=-1)
     endif
  
distinct(r : UUnlimitedNatural) : Boolean
    = not self.equals(r) 

compareTo(r : UUnlimitedNatural) : Integer
    = if self.equals(r) then 0
      else if self.lt(r) then -1 
           else 1 
           endif 
      endif

lt(r : UUnlimitedNatural) : Boolean
   = if (self.x<>-1) and (r.x<>-1) then 
        (self.x<r.x) and ((self.x + self.u)<(r.x - r.u))
     else not ((self.x=-1) and (r.x<>-1)) 
     endif

le(r : UUnlimitedNatural) : Boolean 
   = self.lt(r) or self.equals(r)
    
gt(r : UUnlimitedNatural) : Boolean
   = not self.le(r) 

ge(r : UUnlimitedNatural) : Boolean 
   = not self.lt(r)

max(r : UUnlimitedNatural) : UUnlimitedNatural
   = if (self.x=-1) then self
     else if (r.x=-1) then r 
          else if r.lt(self) then self else r endif
          endif
     endif
   
min(r : UUnlimitedNatural) : UUnlimitedNatural
   = if (self.x=-1) then r
     else if (r.x=-1) then self 
          else if r.lt(self) then self else r endif
          endif
     endif
     
-- comparison operations with Zero

equalsZero() : Boolean 
   = (self.x<>-1) and ((self.x - self.u).max(0.0) <= (self.x + self.u).min(0.0))
  
ltZero() : Boolean
   = (self.x<>-1) and (self.x + self.u)<0.0 

leZero() : Boolean 
   = self.ltZero() or self.equalsZero()
    
gtZero() : Boolean
   = not self.leZero() 

geZero(r : UUnlimitedNatural) : Boolean 
   = not self.lt(r)

-- Fuzzy comparison operations

uEquals(r : UUnlimitedNatural) : UBoolean
    begin
       declare aux1 : UReal, aux2:UReal, aux:UBoolean;
       if (self.x<>-1) and (r.x<>-1) then 
           aux1:=self.toUReal();
           aux2:=r.toUReal();
           result:=aux1.uEquals(aux2);
        else 
           aux:=new UBoolean;
           aux.b:=(self.x=-1) and (r.x=-1);
           aux.c:=1.0;
           if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
           result:=aux;
        end
    end
-- post: result = self.toUReal().uEquals(r.toUReal())

uDistinct(r : UUnlimitedNatural) : UBoolean
    begin
       declare aux1 : UReal, aux2:UReal, aux:UBoolean;
       if (self.x<>-1) and (r.x<>-1) then 
           aux1:=self.toUReal();
           aux2:=r.toUReal();
           result:=aux1.uDistinct(aux2);
        else 
           aux:=new UBoolean;
           aux.b:=(self.x=-1) or (r.x=-1);
           aux.c:=1.0;
           if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
           result:=aux;
        end
    end
-- post: result = self.toUReal().uDistinct(r.toUReal())

uLt(r : UUnlimitedNatural) : UBoolean
    begin
       declare aux1 : UReal, aux2:UReal, aux:UBoolean;
       if (self.x<>-1) and (r.x<>-1) then 
           aux1:=self.toUReal();
           aux2:=r.toUReal();
           result:=aux1.uLt(aux2);
        else 
           aux:=new UBoolean;
           aux.b:=(r.x=-1)and(self.x<>-1);
           aux.c:=1.0;
           if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
           result:=aux;
        end
    end
-- post: result = self.toUReal().uLt(r.toUReal())

uLe(r : UUnlimitedNatural) : UBoolean 
    begin
       declare aux1 : UReal, aux2:UReal, aux:UBoolean;
       if (self.x<>-1) and (r.x<>-1) then 
           aux1:=self.toUReal();
           aux2:=r.toUReal();
           result:=aux1.uLe(aux2);
        else 
           aux:=new UBoolean;
           aux.b:=(r.x=-1);
           aux.c:=1.0;
           if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
           result:=aux;
        end
    end
-- post: result = self.toUReal().uLe(r.toUReal())   

uGt(r : UUnlimitedNatural) : UBoolean
    begin
       declare aux1 : UReal, aux2:UReal, aux:UBoolean;
       if (self.x<>-1) and (r.x<>-1) then 
           aux1:=self.toUReal();
           aux2:=r.toUReal();
           result:=aux1.uGt(aux2);
        else 
           aux:=new UBoolean;
           aux.b:=(self.x=-1)and(r.x<>-1);
           aux.c:=1.0;
           if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
           result:=aux;
        end
    end
-- post: result = self.toUReal().uGt(r.toUReal())

uGe(r : UUnlimitedNatural) : UBoolean 
    begin
       declare aux1 : UReal, aux2:UReal, aux:UBoolean;
       if (self.x<>-1) and (r.x<>-1) then 
           aux1:=self.toUReal();
           aux2:=r.toUReal();
           result:=aux1.uGe(aux2);
        else 
           aux:=new UBoolean;
           aux.b:=(self.x=-1);
           aux.c:=1.0;
           if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
           result:=aux;
        end
    end
-- post: result = self.toUReal().uGe(r.toUReal())


-- Fuzzy comparison operations with Zero=UUnlimitedNatural(0,0.0)

uEqualsZero() : UBoolean
    begin
       declare aux1 : UReal, aux2:UReal, aux:UBoolean, r : UUnlimitedNatural;
       r:=new UUnlimitedNatural;
       r.x:=0;
       r.u:=0.0;
       if (self.x<>-1) and (r.x<>-1) then 
           aux1:=self.toUReal();
           aux2:=r.toUReal();
           result:=aux1.uEquals(aux2);
        else 
           aux:=new UBoolean;
           aux.b:=(self.x=-1) and (r.x=-1);
           aux.c:=1.0;
           if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
           result:=aux;
        end
    end
-- post: result = self.toUReal().uEquals(r.toUReal())

uLtZero() : UBoolean
    begin
       declare aux1 : UReal, aux2:UReal, aux:UBoolean, r : UUnlimitedNatural;
       r:=new UUnlimitedNatural;
       r.x:=0;
       r.u:=0.0;
       if (self.x<>-1) and (r.x<>-1) then 
           aux1:=self.toUReal();
           aux2:=r.toUReal();
           result:=aux1.uLt(aux2);
        else 
           aux:=new UBoolean;
           aux.b:=(r.x=-1)and(self.x<>-1);
           aux.c:=1.0;
           if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
           result:=aux;
        end
    end
-- post: result = self.toUReal().uLt(r.toUReal())

uLeZero() : UBoolean 
    begin
       declare aux1 : UReal, aux2:UReal, aux:UBoolean,r : UUnlimitedNatural;
       r:=new UUnlimitedNatural;
       r.x:=0;
       r.u:=0.0;
       if (self.x<>-1) and (r.x<>-1) then 
           aux1:=self.toUReal();
           aux2:=r.toUReal();
           result:=aux1.uLe(aux2);
        else 
           aux:=new UBoolean;
           aux.b:=(r.x=-1);
           aux.c:=1.0;
           if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
           result:=aux;
        end
    end
-- post: result = self.toUReal().uLe(r.toUReal())   

uGtZero() : UBoolean
    begin
       declare aux1 : UReal, aux2:UReal, aux:UBoolean,r : UUnlimitedNatural;
       r:=new UUnlimitedNatural;
       r.x:=0;
       r.u:=0.0;
       if (self.x<>-1) and (r.x<>-1) then 
           aux1:=self.toUReal();
           aux2:=r.toUReal();
           result:=aux1.uGt(aux2);
        else 
           aux:=new UBoolean;
           aux.b:=(self.x=-1)and(r.x<>-1);
           aux.c:=1.0;
           if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
           result:=aux;
        end
    end
-- post: result = self.toUReal().uGt(r.toUReal())

uGeZero() : UBoolean 
    begin
       declare aux1 : UReal, aux2:UReal, aux:UBoolean, r : UUnlimitedNatural;
       r:=new UUnlimitedNatural;
       r.x:=0;
       r.u:=0.0;
       if (self.x<>-1) and (r.x<>-1) then 
           aux1:=self.toUReal();
           aux2:=r.toUReal();
           result:=aux1.uGe(aux2);
        else 
           aux:=new UBoolean;
           aux.b:=(self.x=-1);
           aux.c:=1.0;
           if (not aux.b) then aux.b:= true; aux.c:=1-aux.c; end;
           result:=aux;
        end
    end
-- post: result = self.toUReal().uGe(r.toUReal())


--- Conversion operations


toUReal() : UReal
    begin
       declare aux : UReal;
       aux:=new UReal;
       aux.x:=self.x;
       aux.u:=self.u;
       result:=aux;
    end
post: result.x=self.x and result.u=self.u

toUInteger() : UInteger
    begin
       declare aux : UInteger;
       aux:=new UInteger;
       aux.x:=self.x;
       aux.u:=self.u;
       result:=aux;
    end
post: result.x=self.x and result.u=self.u

toInteger() : Integer = self.x

toReal() : Real = self.x

toString() : String = 'UUnlimitedNatural{x='+self.x.toString()+'; u='+self.u.toString()+'}'

end

-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

constraints -- precondition on operations

--- UReal

context UReal::divideBy(r : UReal) : UReal
pre: (r.x - r.u).max(0) > (r.x + r.u).min(0) --not r.equals(0,0)

context UReal::sqrt() : UReal
pre:  (self.x + self.u)>=0.0 

context UReal::inverse() : UReal
    pre:  (self.x - self.u).max(0) > (self.x + self.u).min(0) -- not self.equals(0.0)


--- UInteger

context UInteger::divideBy(r : UInteger) : UInteger
pre: (r.x - r.u).max(0) > (r.x + r.u).min(0) --not r.equals(0,0)

context UInteger::divideByR(r : UInteger) : UReal
pre: (r.x - r.u).max(0) > (r.x + r.u).min(0) --not r.equals(0,0)


context UInteger::sqrt() : UInteger
pre:  (self.x + self.u)>=0.0 

context UInteger::inverse() : UInteger
    pre:  (self.x - self.u).max(0) > (self.x + self.u).min(0) -- not self.equals(0.0)

--- UUnlimitedNatural

context UUnlimitedNatural inv WellFormedNumbers:
   (self.x <= -1) and (self.x = -1 implies self.u=0.0)

context UUnlimitedNatural::divideBy(r : UUnlimitedNatural) : UUnlimitedNatural
pre: (r.x - r.u).max(0) > (r.x + r.u).min(0) --not r.equals(0,0)
     and (r.x <> -1) and (self.x <> -1)

context UUnlimitedNatural::divideByR(r : UUnlimitedNatural) : UReal
pre: (r.x - r.u).max(0) > (r.x + r.u).min(0) --not r.equals(0,0)
     and (r.x <> -1) and (self.x <> -1)

context UUnlimitedNatural::add(r : UUnlimitedNatural) : UUnlimitedNatural
pre: (r.x <> -1) and (self.x <> -1)

context UUnlimitedNatural::mult(r : UUnlimitedNatural) : UUnlimitedNatural
pre: (r.x <> -1) and (self.x <> -1)

context UUnlimitedNatural::toReal() : Real
pre: (self.x <> -1)

context UUnlimitedNatural::toUReal() : UReal
pre: (self.x <> -1)

context UUnlimitedNatural::toInteger() : Integer
pre: (self.x <> -1)

context UUnlimitedNatural::toUInteger() : UInteger
pre: (self.x <> -1)
